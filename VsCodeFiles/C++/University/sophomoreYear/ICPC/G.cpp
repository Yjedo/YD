#include<bits/stdc++.h>
using namespace std;

/*
题目描述：
括号序列是指由 ‘(’ 和 ‘)’ 组成的序列，假如一个括号序列中，包含相同数量的左括号和右括号，并且对于每一个右括号，
在他的左侧都有左括号和他匹配，则这个 括号序列就是一个合法括号序列，如（（ ））（ ）就是一个合法括号序列，
但（（ ））（（ ）不是合法括号序列.
给出两个长度相同的合法括号序列 A 和 B , 那么 A < B 当且仅当:
A和B至少有一位不相同
在A和B从左往右数第一个不相同的位置i,A[i] = ( ,B[i]= ) ;
比如A = （（ ））（）, B = （ ）（ ） （ ）， 则 A < B 。因为从左边数第一个不相同的是第二个字符，
A[2] = ( , B[2] = )。对于长度 N，由于定义了小于关系，则可以通过这个关系推出所有长度为N的合法括号序列的大小关系，
对于长度为6的合法括号序列，从小到大排列顺序如下:
（（（ ）））
（（）（））
（（ ））（ ）
（ ）（（ ））
（ ）（ ）（ ）
给出 N 和 M， 求长度为 N 的合法括号序列中， 第 M 小的合法括号序列是？
输入
输入的第一行是 N 和 M
2 <= N <= 2000
1 <= M <= 10^18
输出
输出一个字符串，表示长度为 N 的平衡括号序列从小到大排列， 序号为 M 的字符串
样例输入
6 2
1
样例输出
( ( ) ( ) )
1
*/
/*
    分析：根据题目要求，我们需要做的就是求长度为 N 的合法括号序列中， 第 M 小的合法括号序列是什么。
          该问题有几个难点: 1.长度为N的合法括号序列如何获得，
                           2.如何对之进行排序，或者说如何锁定第M小的括号序列

*/
typedef long long ll;
const int maxn = 2010;
const ll inf = 1e18 + 1;
int n, k;
ll f[maxn][maxn];
char ans[maxn];
int main()
{
    scanf("%d%d", &n, &k);
    f[0][0] = 1;
    for (int i = 1; i <= n; i++)
    {
        for (int j = 0; j <= n; j++)
        {
            if (f[i - 1][j])
            {
                f[i][j + 1] += f[i - 1][j];
                if (j)
                    f[i][j - 1] += f[i - 1][j];
                f[i][j + 1] = min(f[i][j + 1], inf);
                if (j)
                    f[i][j - 1] = min(f[i][j - 1], inf);
            }
        }
    }

     for (int i = 0; i <= n; i++)
    {
        for (int j = 0; j <= n; j++)
        {
            cout << f[i][j] << " ";
        }
        cout << endl;
    }
    int now = 0;
    for (int i = 1; i <= n; i++)
    {
        if (f[n - i][now + 1] >= k)
            ans[i] = '(', ++now;
        else
            ans[i] = ')', k -= f[n - i][now + 1], --now;
    }
    puts(ans + 1);
    return 0;
}